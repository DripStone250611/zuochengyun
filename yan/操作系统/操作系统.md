## 第 2 章 进程与线程

### 2.3 同步与互斥

#### 2.3.1 同步与互斥的基本概念

**1、临界资源**

将一次仅允许一个进程使用的资源称为临界资源。对临界资源的访问必须互斥的进行，访问临界资源的那段代码称为临界区。

1. 进入区
2. 临界区
3. 退出区
4. 剩余区

**2、同步**

同步也称直接制约关系，是指为完成某种任务二建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。

**3、互斥**

互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区 后，另一个进程才允许访问此临界资源。

为禁止两个进程同时进入临界区，同步机制应遵循以下准则：

1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
2. 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。
4. 让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。

#### 2.3.2 实现临界区互斥的基本方法

**1、软件实现方法**

在进入区设置并检查一些标志来表明是否有进程在临界区中，若已有进程在临界区中，在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。

1）算法一：单标志法。该算法设置一个公共整型变量turn，用于指示被允许进入临界区的进程编号。若turn=0，则允许P~0~进程进入临界区。该算法可以保证每次只允许一个进程进入临界区。但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法在进入临界区（违背“空闲让进”）。

```c
// P0进程
while(turn != 0);			// 进入区
critical section;			// 临界区
turn = 1；						 // 退出区
remainder section;    // 剩余区

// P1进程
while(turn != 1);			// 进入区
critical section;			// 临界区
turn = 0；						 // 退出区
remainder section;    // 剩余区
```

2）算法二：双标志法先检查。

在每个进程访问临界资源之前，先查看临界资源是否正在被访问，若正在被访问，该进程需要等待。否则，进程才能进入自己的临界区。设置一个布尔型的flag数组，如第i个元素flag[i]为FALSE，表示P~i~进程未进入临界区，如为TRUE，表示P~i~进程进入临界区。

```c
// pi进程
while(flag[j]);				// 进入区
flag[i] = TRUE;				// 进入区
critical section;			// 临界区
flag[i] = FALSE;			// 退出区
remainder section;		// 剩余区

// pj进程
while(flag[i]);				// 进入区
flag[j] = TRUE;				// 进入区
critical section;			// 临界区
flag[j] = FALSE;			// 退出区
remainder section;		// 剩余区
```

优点：不用交替使用，可连续使用。缺点：两进程可能会同时进入临界区，违背“忙则等待”。

3）算法三：双标志法后检查

现将自己标志设为TRUE，再检查对方的状态标志，若对方的状态标志为TRUE，则进程等待。

```c
// pi进程
flag[i] = TRUE;				// 进入区
while(flag[j]);				// 进入区
critical section;			// 临界区
flag[i] = FALSE;			// 退出区
remainder section;		// 剩余区

// pj进程
flag[j] = TRUE;				// 进入区
while(flag[i]);				// 进入区
critical section;			// 临界区
flag[j] = FALSE;			// 退出区
remainder section;		// 剩余区
```

可能会出现死锁的情况。

4）算法四：Peterson's Algorithm。每个进程先设置自己的标志后再设置turn标志。这时，同时在检测另一个进程标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。

```c
// pi 进程：
flag[i] = TRUE; turn = j;			// 进入区
while(flag[j] && turn==j);		// 进入区
critical section;							// 临界区
flag[i] = FALSE;							// 退出区
remainder section;						// 剩余区

// pj 进程：
flag[j] = TRUE; turn = i;
while(flag[i] && turn == i);
critical section;
flag[i] = FALSE;
remainder section;
```

**2. 硬件实现方法**

通过硬件支持实现临界段问题的方法称为低级方法，或称元方法。

（1）中断屏蔽方法

当一个进程正在执行它的临界区代码时，防止其他进程进入其临界区的最简方法就是关中断。

（2）硬件指令方法

`TestAndSet指令`：这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真。

```c
boolean TestAndSet(boolean *lock){
  boolean old;
  old =*lock;
  *lock = true;
  return old;
}
```

可以为每个临界资源设置一个共享布尔变量lock，表示资源的两种状态：true表示正在占用，初值为false。进程进入临界区之前，利用TestAndSet检查标志lock，若无进程在临界区，则其值为false，可以进入，关闭临界资源，把lock置为true，使任何进程都不能进入临界区；若有进程在临界区，则循环检查，直至进程退出。使用该指令实现互斥的过程描述如下：

```c
while TestAndSet(&lock);
进程的临界区代码
lock=false;
进程的其他代码;
```

`Swap指令`：该指令的功能是交换两个字（字节）的内容。其功能描述如下：

```c
Swap(boolean *a, boolean *b){
    boolean temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```

注意：以上对TestAndSet和Swap指令的描述仅是功能实现，而并非软件实现的定义，事实上，它们是由硬件逻辑直接实现的，不会被中断。

用Swap指令可以简单有效的实现互斥，为每个临界资源设置一个共享布尔变量lock，初值为false；每个进程中再设置一个局部布尔变量key，用于与lock交换信息。在进入临界区前，先利用swap交换lock和key的内容，然后检查key的状态；有进程在临界区时，重复交换和检查过程，直至进程退出。

```c
key = true;
while(key != false)
    Swap(&lock, &key);
进程的临界区代码
lock = false;
进程的其他代码；
```



#### 2.3.3 互斥锁

解决临界区最简单的工具就是互斥锁。一个进程在进入临界区时应获得锁，在退出临界区时释放锁。函数acquire()获得锁，函数release()释放锁。

每个互斥锁有一个布尔变量available ，表示锁是否可用。如果锁是可用的，调用acquire会成功，且锁不再可用。当一个进程试图获取不可用锁时，会被阻塞，直到锁被释放。

```c
acquire(){
    while(!available);
    available = false;
}
release(){
    available = true;
}
```

acquire ()或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。

互斥锁的主要缺点就是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire。当多个进程共享同一个CPU时，就浪费了CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。

#### 2.3.4 信号量

信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语wait(S)和signal（S）访问，也可以记为“P操作”和“V操作”。

**1、整型信号量**

整型信号量被定义为一个用于表示资源数目的整型量S，wait和signal操作可描述为

```c
wait(S){
    while(S<=0);
    S=S-1;
}
signal(S){
    S=S+1;
}
```

在整型信号量机制中的wait操作，只要信号量S<=0,就会不断地测试，因此，该机制并未遵循“让权等待”的原则。

**2、记录型信号量**

记录型信号量机制是一种不存在“忙等”现象的进程同步机制。除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构。记录型信号量可描述为

```java
typedef struct{
    int value;
    struct process *L;
} semaphore;

void wait(semaphore S){
    S.value--;
    if(S.value < 0){
        add this process to S.L;
        block(S.L);
    }
}

void signal(semaphore S){
    S.value++;
    if(S.value <= 0){
        remove a process P from S.L;
        wakeup(P);
    }
}
```

**3、利用信号量实现同步**

信号量机制能用于解决进程间的各种同步问题。设S为实现进程P~1~,P~2~同步的公共信号量，初值为0.进程P~2~中的语句y要使用进程P~1~中语句x的运行结果，所以只有当语句x执行完成之后语句y才可以执行。其实先进程同步的算法如下：

```c
semaphore S = 0;			// 初始化信号量
P1(){
    x;						// 语句x
    V(S);					// 告诉进程P2，语句x已经完成
    ...
}
P2(){
    ...
    P(S);					// 检查语句x是否运行完成
    y;						// 检查无误，运行y语句
    ...
}
```

**4、利用信号量实现进程互斥**

信号量机制也能很方便的解决进程互斥问题。设S为实现进程P~1~,P~2~互斥的信号量，由于每次只允许一个进程进入临界区，所以S的初值应为1（即可用资源数为1），只需把临界区置于P(S)和V(S)之间，即可实现连个进程对临界资源的互斥访问。其算法如下：

```c
semaphore S = 1;			// 初始化信号量
P1(){
    ...
    P(S);					// 准备开始访问临界资源,加锁
    进程P1的临界区;
    V(S);					// 访问结束，解锁
}
P2（）{
    ...
    P(S);
    进程P2的临界区；
    V(S);
}
```

**5、 利用信号量实现前驱关系**

![](img/2-1.png)

```c
semaphore a1=a2=b1=b2=c=d=e=0;				// 初始化信号量
S1(){
    ...;
    V(a1);V(a2);							// S1 已经完成
}
S2(){
    P(a1);									// 检查S1是否已经完成
    ...;
    V(b1);V(b2);							// S2 已经运行完成
}
S3(){
    P(a2);									// 检查S1是否运行完成
    ...;
    V(c);									// S3 已经运行完成
}
S4(){
    P(b1);									// 检查S2是否运行完成
    ...;
    V(d);									// S4已经运行完成
}
S5(){
    P(b2);									// 检查S2是否已经完成
    ...;
    V(e);									// S5已经运行完成
}
S6(){
    P(c);									// 检查S3是否已经完成
    P(d);									// 检查S4是否已经完成
    P(e);									// 检查S5是否已经完成
    ...;
}
```



#### 2.3.5 管程

在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致系统死锁。于是，便产生了一种新的进程同步工具——管程。管程的特性保证了进程互斥，无需程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活的实现进程同步。

**1、管程的定义**

管程：共享资源的数据结构 + 对该数据结构实施操作的一组过程所组成的资源管理程序。

管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作。

管程由四部分组成：

1. 管程的名称。
2. 局部于管程内部的共享数据结构说明。
3. 对该数据结构进行操作的一组函数。
4. 对局部于管程内部的共享数据设置初始值的语句。

```c
monitor Demo{ // 定义一个名称为“Demo"的管程
    
    // 定义共享数据结构
    共享数据结构s；
    
    // 对共享数据结构初始化的语句
    init_code(){
        S=5;
    }
    
    // 定义管程的操作函数
    take_away(){
        对共享数据结构x的一系列处理
        S--；
    }
    
    // 定义管程的操作函数
    give_back(){
        对共享数据结构的一系列操作
    }
}
```

**2、条件变量**

条件变量用于控制进程的阻塞。通常一个进程被阻塞的原因可以有很多个，因此在管程中设置了多个条件变量。每个条件变量保存一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作，即wait和signal。

`x.wait`：当x对应的条件不满足时，正在调用管程的进程使用`x.wait`将自己插入x条件的等待队列，并释放管程。此时其他进程可以使用该管程。

`x.signal`：x对应的条件发生了变化，则调用`x.signal`，唤醒一个因x条件而阻塞的进程。

```c
monitor Demo{
    共享数据结构 S;
    condition x;
    init_code(){ ... }
    take_away(){
        if(S <= 0)  x.wait();	// 资源不够，在条件变量x上阻塞等待
        资源充足，分配资源，做一系列相应处理；
    }
    give_back(){
        归还资源，做一系列相应处理
        if(有进程在等待)  x.signal(); // 唤醒一个阻塞进程
    }
}
```

条件变量和信号量的比较：

相似点：条件变量的wait/signal操作类似于信号量的P/V操作，可以实现进程的阻塞/唤醒。

不同点：条件变量是"没有值"的,仅实现了排队等待功能；而信号量是有值的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。



#### 2.3.6 经典同步问题

**1、生产者-消费者问题**

**问题描述：**一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从缓冲区中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。

**问题分析：**

1. 关系分析：生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，它们也是同步关系。
2. 整理思路：只有生产者和消费者两个进程，正好这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。
3. 信号量设置：信号量mutex作为互斥信号量，用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中”满“缓冲区数，初值为0。信号量empty用于记录当前缓冲池中的”空“缓冲区数，初值为n。

```c
semaphore mutex = 1;						// 临界区互斥信号量
semaphore empty = n;						// 空闲缓冲区
semaphore full = 0;							// 缓冲区初始化为空
producer(){
    while(1){
        produce an item in nextp;			// 生产数据
        P(empty);							// 获取空缓冲区单元
        P(mutex);							// 进入临界区
        add nextp to buffer;				// 将数据放入缓冲区
        V(mutex);							// 离开临界区，释放互斥信号量
        V(full);							// 满缓冲区加1
    }
}
consumer(){
    while(1){
        P(full);
        P(mutex);
        remove an item from buffer;
        V(mutex);
        V(empty);
        consume the item;
    }
}
```



另一个复杂的生产者—消费者问题

**问题描述：**桌子上有一个盘子，每次只能香气中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘中取出。

**问题分析：**

1. 关系分析：爸爸和妈妈是互斥关系、爸爸和女儿、妈妈和儿子是同步关系，儿子和女儿之间没有同步和互斥关系。
2. 整理思路：这里有四个进程，可以抽象为两个生产者和两个消费者被链接到大小为1的缓冲区上。
3. 信号量设置：首先，将信号量plate设置互斥信号量，表示是否允许向盘子里放入水果，初值为1表示允许放入，且只允许放入一个。信号量apple表示盘子中是否有苹果，初值为0表示盘子为空，不许取，apple=1表示可以取。信号量orange表示盘子中是否有橘子，初值为0表示盘子为空，不许取。

```c
semaphore plate = 1, apple = orange = 0;
dad(){
    P(plate);
    put an apple on the plate;
    V(apple);
}
mom(){
    P(plate);
    put an orange on the plate;
    V(orange);
}
son(){
    P(orange);
    take an apple from the plate;
    V(plate);
}
daughter(){
    P(apple);
    take an apple from the plate;
    V(plate);
}
```

**2、读者—写者问题**

**问题描述：**有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：1、允许多个读者可以同时对文件执行读操作；2、只允许一个写着往文件中写数据；3、任意一个写者在完成写操作之前不允许其他读者或写者工作；4、写者执行写操作之前，应让已有的读者和写者全部退出。

**问题分析：**

1. 关系分析。读者和写者之间是互斥的，写者和写者之间也是互斥的，而读者和读者之间不存在互斥问题。
2. 整理思路。两个进程，即读者和写者。写者是比较简单的，他和任何进程互斥，用互斥信号量的P、V操作可以解决。读者问题比较复杂，他必须在实现与写者互斥的同时，实现与其他读者的同步，因此简单的一对P、V操作是无法解决问题的。这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者读文件时，写者是无法写文件的，此时读者会一直占用文件，当没有读者时，写者才可以写文件。同时，这里不同读者对计数器的访问也应该是互斥的。
3. 信号量设置。首先设置信号量count为计数器，用于记录当前读者的数量，初值为0；设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw，用于保证读者和写者的互斥访问。

代码如下：

```c
int count = 0;					// 用于记录当前的读者数量
semaphore mutex = 1;			// 用于保护更新count变量时的互斥
semaphore rw = 1;				// 用于保证读者和写者互斥地访问文件
writer(){						// 写者进程
    while(1){
        P(rw);					// 互斥访问共享文件
        writing;
        V(rw);
    }
}
reader(){
    while(1){
        P(mutex);
        if(count == 0)
            P(rw);
        count++;
        V(mutex);
        reading;
        P(mutex);
        count--;
        if(count == 0)
            V(rw);
        V(mutex);
    }
}
```

在上面地算法中，读进程是优先地，即当存在读进程时，写操作将被延迟，且只要有一个读进程活跃，随后而来地读进程都将被允许访问文件。这样的方式会导致写进程可能长时间等待，且存在写进程“饿死”地情况。

若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程地请求，等到已在共享文件地读进程执行完毕，立即让写进程执行，只有在无写进程执行地情况下，才允许读进程再次运行。为此，增加一个信号量并在上面程序地writer()和reader()函数中各增加一对PV操作，就可以得到写进程优先地解决程序。

```c
int count = 0;
semaphore mutex = 1;
semaphore rw=1;
semaphore w=1;
writer(){
    while(1){
        P(w);				// 在无写进程请求时进入
        P(rw);				// 互斥访问count变量
        writing;
        V(rw);				// 释放共享文件
        V(w);				// 恢复对共享文件地访问。			
    }
}
reader(){
    while(1){
        P(w);
        P(mutex);
        if(count == 0)
            P(rw);
        count++;
        V(mutex);
        V(w);
        reading;
        P(mutex);
        count--;
        if(count == 0)
            V(rw);
        V(mutex);
    }
}
```

**3、哲学家进餐问题**

**问题描述：**一张圆桌边上坐着5名哲学家，每两名哲学家之间地桌上摆一根筷子，两根筷子中间是一碗米饭，哲学家倾注毕生精力用于思考和进餐，哲学家在思考时，不影响其他人。只有当哲学家饥饿时，才会拿起两根筷子来进餐（一根一根拿起）。若筷子已在他人手上，则需要等待。饥饿地哲学家只有同时拿到两根筷子才可以开始进餐，进餐完毕后，放下筷子继续思考。

<img src="img\2-2.png" style="zoom:80%;" />

**问题分析：**

1. 关系分析。5名哲学家与左右邻居对其中间筷子地访问是互斥的。
2. 整理思路。显然，这里有5个进程。本题的关键是如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象。解决方法有两个：一是让他们同时拿两根筷子；二是对每名哲学家的动作指定规则，避免饥饿或死锁现象的发生。
3. 信号量设置。定义互斥信号量数组chopstick[5]={1,1,1,1,1},用于对5个筷子的互斥访问。哲学家按顺序编号为0~4，哲学家i左边筷子的编号为i，哲学家右边筷子的编号为（i+1）%5 。

```c
semaphore chopstick[5] = {1,1,1,1,1};
Pi(){
    do{
        P(chopstick[i]);
        P(chopstick[(i+1)/5]);
        eat;
        V(chopstick[i]);
        V(chopstick[(i+1)%5]);
        think;
    }while(1);
}
```

上述算法存在一些问题：当5名哲学家都想要进餐并分别拿起左边的筷子时，筷子已经被拿光，等到他们再想拿右边的筷子时，就全被阻塞了，因此发生了死锁。

为防止死锁发生，可对哲学家进程施加一些限制条件，比如至多允许4名哲学家同时进餐；仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子；对哲学家顺序编号，要求奇数号哲学家先拿左边的筷子，然后拿右边的筷子，而偶数号科学家则正好相反。

**制定正确的规则如下：**假设采用第二种方法，当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子。

```c
semaphore chopstick[5] = {1,1,1,1,1};
semaphore mutex = 1;
Pi(){
    do{
        P(mutex);
        P(chopstick[i]);
        P(chopstick[(i+1)%5]);
        V(mutex);
        eat;
        V(chopstick[i]);
        V(chopstick[(i+1)%5]);
        think;
    }while(1);
}
```

**4、吸烟者问题**

问题描述：假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起来并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料地抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放到桌上，如此重复。

**问题分析：**

1、关系分析。供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或以上地抽烟者，三个抽烟者对抽烟这个动作互斥（或由三个抽烟者轮流抽烟得知）。

2、整理思路。显然这里有4个进程。供应者作为生产者向三个抽烟者提供材料。

3、信号量设置。信号量offer1，offer2，offer3分别表示烟草和纸组合得资源、烟草和胶水组合得资源、纸和胶水组合得资源。信号量finish用于互斥进行抽烟动作。

```c
int num = 0;				// 储存随机数
semaphore offer1 = 0;
semaphore offer2 = 0;
semaphore offer3 = 0;
semaphore finish = 0;
process P1(){
    while(1){
        num++;
        num = num % 3;
        if(num == 0)
            V(offer1);
        else if(num == 1)
            V(offer2);
        else
            V(offer3);
        P(finish);
    }
}
process P2(){
    while(1){
        P(offer3);
        V(finish);
    }
}
```

#### 2.3.8 习题

**一、单选**

|  1   |  2   |  3   |  4   |   5    |
| :--: | :--: | :--: | :--: | :----: |
|  D   |  D   | C(A) |  C   |   C    |
|  6   |  7   |  8   |  9   |   10   |
|  D   |  D   |  B   |  B   |   C    |
|  11  |  12  |  13  |  14  |   15   |
|  C   |  D   |  C   |  D   |   A    |
|  16  |  17  |  18  |  19  |   20   |
|  C   |  B   | B(D) |  C   |   D    |
|  21  |  22  |  23  |  24  |   25   |
|  D   |  A   |  B   |  C   |   D    |
|  26  |  27  |  28  |  29  |   30   |
|  C   |  C   | D(C) | B(A) | CC(CB) |
|  31  |  32  |  33  |  34  |   35   |
|  B   |  C   |  B   |  B   |   D    |
|  36  |  37  |  38  |  39  |   40   |
|  C   |  A   |  B   |  C   |   B    |
|  41  |  42  |  43  |  44  |   45   |
| C(D) |  C   |  C   | A(B) |  C(A)  |
|  46  |  47  |  48  |  49  |        |
|  B   | C(D) |  C   |  C   |        |

### 2.4 死锁

#### 2.4.1 死锁的概念

**1、死锁的定义**

死锁：是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。

**2、死锁产生的原因**

（1）系统资源的竞争

只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。

（2）进程推进顺序非法

进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。信号量使用不当也会造成死锁。

**3、死锁产生的必要条件**

产生死锁必须同时满足以下4个条件，只要其中一个条件不成立，死锁就不会发生。

（1）互斥条件

（2）不可剥夺条件

（3）请求并保持条件。进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

（4）循环等待条件。

**4、死锁的处理策略**

为使系统不发生死锁，必须设法破坏产生死锁的4个必要条件之一，或允许死锁产生，但当死锁发生时，能检测出死锁，并有能力实现恢复。

（1）死锁预防。设置某些限定条件，破坏产生死锁的4个必要条件中的一个或几个。

（2）避免死锁。在资源的动态分配过程中，用某种方法防止系统进入不安全的状态。

（3）思索地检测和解除。无须采取任何限制性措施，允许进程在运行过程中发生死锁。

#### 2.4.2 死锁预防

**1、破坏互斥条件**

**2、破坏不剥夺条件**

当一个已保持了某些不可剥夺资源的进程请求新的资源得不到满足时，他必须释放已经保持的所有资源，待以后需要时再重新申请。这一策略实现起来比较复杂，释放已获的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。

**3、破坏请求并保持条件**

采用预先静态分配方法，即进程在运行前一次申请完它所需要地全部资源，在它的资源未满足前，不把它投入运行，一旦投入运行，这些资源就一直归它所有。这种方式实现简单，但是缺点是系统资源被浪费严重。

**4、破坏循环等待条件**

为了破坏循环等待条件，可采用顺序资源分配法。首先给系统种的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。这种方法存在的问题是，资源编号需要稳定，限制了新设备的增加。



#### 2.4.3 死锁避免

**1、系统安全状态**

允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配地安全性。若此次分配不会导致系统进入不安全状态，则允许分配；否则让进程等待。

**2、银行家算法**

银行家算法是著名地死锁避免算法。进程运行之前先声明对各种资源地最大需求量，当，进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该进程声明的最大需求量。若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。

（1）数据结构描述

可利用资源向量Available：含有m个元素的数组，其中每个元素代表一类可用的资源数目。Available[j] = K表示系统中现有R~j~类资源K个。

最大需求矩阵Max：n×m矩阵，定义系统中n个进程中每个进程对m类资源的最大需求。

分配矩阵Allocation：n×m矩阵，定义系统中每类资源当前已分配给每个进程的资源数。

需求矩阵Need：n×m矩阵，表示每个进程接下来最多还需要多少资源。

（2）银行家算法描述
