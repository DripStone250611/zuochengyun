## 第 2 章 进程与线程

### 2.3 同步与互斥

#### 2.3.1 同步与互斥的基本概念

**1、临界资源**

将一次仅允许一个进程使用的资源称为临界资源。对临界资源的访问必须互斥的进行，访问临界资源的那段代码称为临界区。

1. 进入区
2. 临界区
3. 退出区
4. 剩余区

**2、同步**

同步也称直接制约关系，是指为完成某种任务二建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。

**3、互斥**

互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区 后，另一个进程才允许访问此临界资源。

为禁止两个进程同时进入临界区，同步机制应遵循以下准则：

1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
2. 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。
4. 让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。

#### 2.3.2 实现临界区互斥的基本方法

**1、软件实现方法**

在进入区设置并检查一些标志来表明是否有进程在临界区中，若已有进程在临界区中，在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。

1）算法一：单标志法。该算法设置一个公共整型变量turn，用于指示被允许进入临界区的进程编号。若turn=0，则允许P~0~进程进入临界区。该算法可以保证每次只允许一个进程进入临界区。但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法在进入临界区（违背“空闲让进”）。

```c
// P0进程
while(turn != 0);			// 进入区
critical section;			// 临界区
turn = 1；						 // 退出区
remainder section;    // 剩余区

// P1进程
while(turn != 1);			// 进入区
critical section;			// 临界区
turn = 0；						 // 退出区
remainder section;    // 剩余区
```

2）算法二：双标志法先检查。

在每个进程访问临界资源之前，先查看临界资源是否正在被访问，若正在被访问，该进程需要等待。否则，进程才能进入自己的临界区。设置一个布尔型的flag数组，如第i个元素flag[i]为FALSE，表示P~i~进程未进入临界区，如为TRUE，表示P~i~进程进入临界区。

```c
// pi进程
while(flag[j]);				// 进入区
flag[i] = TRUE;				// 进入区
critical section;			// 临界区
flag[i] = FALSE;			// 退出区
remainder section;		// 剩余区

// pj进程
while(flag[i]);				// 进入区
flag[j] = TRUE;				// 进入区
critical section;			// 临界区
flag[j] = FALSE;			// 退出区
remainder section;		// 剩余区
```

优点：不用交替使用，可连续使用。缺点：两进程可能会同时进入临界区，违背“忙则等待”。

3）算法三：双标志法后检查

现将自己标志设为TRUE，再检查对方的状态标志，若对方的状态标志为TRUE，则进程等待。

```c
// pi进程
flag[i] = TRUE;				// 进入区
while(flag[j]);				// 进入区
critical section;			// 临界区
flag[i] = FALSE;			// 退出区
remainder section;		// 剩余区

// pj进程
flag[j] = TRUE;				// 进入区
while(flag[i]);				// 进入区
critical section;			// 临界区
flag[j] = FALSE;			// 退出区
remainder section;		// 剩余区
```

可能会出现死锁的情况。

4）算法四：Peterson's Algorithm。每个进程先设置自己的标志后再设置turn标志。这时，同时在检测另一个进程标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。

```c
// pi 进程：
flag[i] = TRUE; turn = j;			// 进入区
while(flag[j] && turn==j);		// 进入区
critical section;							// 临界区
flag[i] = FALSE;							// 退出区
remainder section;						// 剩余区

// pj 进程：
flag[j] = TRUE; turn = i;
while(flag[i] && turn == i);
critical section;
flag[i] = FALSE;
remainder section;
```

**2. 硬件实现方法**

通过硬件支持实现临界段问题的方法称为低级方法，或称元方法。

（1）中断屏蔽方法

当一个进程正在执行它的临界区代码时，防止其他进程进入其临界区的最简方法就是关中断。

（2）硬件指令方法

TestAndSet指令：这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真。

```c
boolean TestAndSet(boolean *lock){
  boolean old;
  old =*lock;
  *lock = true;
  return old;
}
```

可以为每个临界资源设置一个共享布尔变量lock，表示资源的两种状态：true表示正在占用，初值为false。进程进入临界区之前，利用TestAndSet检查标志lock，若无进程在临界区，则其值为false，可以进入，关闭临界资源，把lock置为true。





